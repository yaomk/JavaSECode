# 方式一（抓抛模型）：try-catch-finally

* 过程1：‘抛’
    * 程序在执行的过程当中，一旦出现异常，就会在出现异常的代码处，生成对应异常类的对象，并将此对象抛出。一旦抛出，此程序就不执行其后的代码了。
* 过程2：‘抓’
    * 针对过程1中抛出的异常对象，进行捕获处理。此捕获处理的过程中，就称为‘抓’。一旦将异常进行了处理，代码就可以继续执行。

## 基本结构：

```
try {
  ... // 可能产生异常的代码  
} catch(异常类型1 e) {
  ... // 当产生异常类型1异常时的处置措施
} catch(异常类型2 e) {
  ... // 当产生异常类型2异常时的处置措施
} finally {
  ... // 无论是否发生异常，都无条件执行的语句
}
```

## 使用细节：

* 将可能出现异常的代码声明在 try 语句中。一旦出现代码出现异常，就会自动生成一个对应异常类的对象。并将此对象抛出。
* 针对 try 中抛出的异常类的对象，使用之后的 catch 语句进行匹配。一旦匹配上，就进入 catch 语句块进行处理。一旦处理结束，代码就继续执行。
* 如果声明了多个 catch 结构，不同的异常类型在不存在子父类关系的情况下，谁声明在上面，谁声明在下面都可以。如果多个异常类型满足子父类的关系，则必须将子类声明在父类结构的上面。否则，编译报错。
* catch 中异常处理的方式：
    * 自己编写输出的语句。
    * `public void printStackTrace()`: 打印异常的详细信息。(推荐)
    * `public String getMessage()`: 获取发生异常的原因。
* try 中声明的变量，出了 try 结构之后，就不可以调用了。
* try catch 结构是可以嵌套使用的。

### 开发体会：

* 对于运行时异常：
    * 开发中，通常就不进行显示的处理了。一旦在程序执行中，出现了运行时异常，那么就根据异常的提示信息修改代码。
* 对于编译时异常：
    * 一定要进行处理，否则编译不通过。

### finally 使用说明：

#### finally 的理解

* 将一定要执行的代码声明在 finally 结构中。
* 无论 try 中或 catch 中是否存在仍未被处理的异常，无论 try 中或 catch 中是否存在 return 语句等，finally 中声明的语句都一定会执行。

#### 什么样的代码一定要声明在 finally 中？

* 在开发中，有一些资源（比如：输入流，输出流，数据库连接，Socket 连接等资源），在使用完以后，必须显示的进行关闭操作，否则，GC
  不会自动地回收这些资源。进而导致内存的泄漏。
    * 为了保证这些资源在使用完以后，不管是否出现了未被处理的异常的情况下，这些资源能被关闭。我们必须将这些操作声明在
      finally 中。

### 面试题

final，finally，finalize 区别

* `final`： 修饰符（关键字），表示“最终的”或“不可改变的”。修饰变量，方法，类。
    * 变量：一旦初始化后就不能被重新赋值。
    * 方法：不能够被子类重写。
    * 类：不能被继承，不能有子类。
* `finally`：异常处理的一部分，try-catch-finally。
* `finalize`：finalize 是 `java.lang.Object` 类的一个方法。
    * 其设计初衷是用于 清理工作。
    * 从JDK 9开始，被标记为弃用（deprecated）。由于执行时机不确定、可能被多次调用以及可能导致对象复活等问题被弃用。