## 线程间的通信

当我们需要多个线程来共同完成一件任务，并且我们希望他们 **有规律的执行**，那么多线程之间需要一些通信机制，可以协调它们的工作，以此实现多线程共同操作一份数据。

比如：线程 A 用来生产包子的，线程 B 用来吃包子的，包子可以理解为同一资源，线程 A 与线程 B 处理的动作，一个是生产，一个是消费，此时线程
B 必须等到线程 A 完成后才能执行，那么线程 A 与线程 B 之间就需要线程通信，即--**等待唤醒机制**。

### 涉及三个方法的使用：

* `wait()`: 线程一旦执行此方法，就会进入等待状态。同时，会释放对同步监视器的调用。
* `notify()`: 一旦执行此方法，就会唤醒被 `wait()` 的线程中优先级最高的那一个线程。（如果被 `wait()`
  的多个线程的优先级相同，就随机唤醒一个）。被唤醒的线程从当初被 `wait()` 的位置继续执行。
* `notifyAll()`: 一旦执行此方法。就会唤醒所有被 `wait()` 的线程。

### 注意点：

* 上边三个方法的使用，必须是在同步代码块或同步方法中。
* 上边三个方式的调用者，必须是同步监视器。否则，会报：`IllegalMonitorStateException`(非法监视器状态异常)。
* 上边三个方法声明在 Object 类中。
* `Lock` 需要配合 `Condition` 实现线程间的通信。

### wait() 和 sleep() 的区别？

相同点：

* 一旦执行，当前线程都会进入阻塞的状态。
  不同点：
* 声明的位置：
    * `wait()`: 是声明在 Object 类中。
    * `sleep()`: 是声明在 Thread 类中，且是静态的。
* 使用的场景不同：
    * `wait()`: 只能使用在同步代码块或同步方法中。
    * `sleep()`: 可以在任何需要使用的场景。
* 使用在同步代码块或同步方法中：
    * `wait()`: 一旦执行，会释放同步监视器。
    * `sleep()`: 一旦执行，不会释放同步监视器。
* 结束阻塞的方式：
    * `wait()`: 到达指定时间自动结束阻塞，或被 `notify()`: 唤醒，结束阻塞。
    * `sleep()`: 到达指定时间自动结束阻塞。
