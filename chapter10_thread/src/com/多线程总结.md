# 多线程总结

## 复习

### 概念

> 程序（program）：为完成特定任务，用某种语言编写的**一组指令的集合**。即一段静态的代码。
>
> 进程（progress）：程序的一次执行过程，或是正在内存中运行的应用程序。程序是静态的，进程是动态的。**进程作为操作系统调度和分配资源的最小单位。
**
>
> 线程（thread）：进程可进一步细化为线程，是程序内部的一条执行路径。**线程作为 CPU 调度和执行的最小单位。**
>

* <span style='color:red'>一个进程包含多个线程，至少包含一个线程。</span>

* <span style='color:red'>栈管运行，堆管存储。</span>

线程调度策略

* 分时调度：所有线程`轮流使用` CPU 的使用权，并且平均分配每个线程占用 CPU 的时间。
* 抢占式调度：让`优先级高`的线程以`较大的概率`优先使用 CPU。如果线程的优先级相同，那么会随机选择一个（线程随机性）。Java
  使用的为抢占式调度。

扩展

* 单核 CPU 与多核 CPU
* 并行与并发

### 如何创建多线程（重点）

* 方式1：继承 Thread 类
* 方式2：实现 Runnable 接口
* 方式3：实现 Callable 接口（jdk5.0新增）
* 方式4：使用线程池（jdk5.0新增）

### Tread类的常用方法、线程的声明周期

线程中的构造器

* `public Thread()`: 分配一个新的线程对象。
* `public Thread(String name)`: 分配一个指定名字的新的线程对象。
* `public Thread(Runnable target)`: 指定创建线程的目标对象，它实现了 Runnable 接口中的 run 方法。
* `public Thread(Runnable target, String name)`: 分配一个带有指定目标新的线程对象并指定名字。

线程中常用的方法：

* `start()`: ①启动线程 ②调用线程的run()。
* `run()`: 将线程要执行的操作，声明在 run() 中。
* `currentThread()`: 获取当前执行代码对应的线程。
* `getName()`: 获取线程名称
* `setName()`: 设置线程名称
* `sleep(long millis)`: 静态方法，调用时，可以使得当前线程睡眠指定的毫秒数。
* `yield()`: 静态方法，一旦执行此方法，就释放 CPU 的执行权。
* `join()`: 在线程 a 中通过线程 b 调用 join()，意味着线程 a 进入阻塞状态，知道线程 b 执行结束，线程 a 才结束阻塞状态，继续执行。
* `isAlive()`: 判断当前线程是否存活。

线程的优先级：

* `getPriority()`: 获取线程的优先级。
* `setPriority()`: 设置线程的优先级。范围 [1,10]

Tread类内部声明的三个常量：

* `MAX_PRIORITY(10)`: 最高优先级
* `MIN_PRIORITY(1)`: 最低优先级
* `NORM_PRIORITY(5)`: 普通优先级，默认情况下 main 线程具有普通优先级。

线程的生命周期:

* jdk5.0之前：
  <img src="./atguigu02/method_lifecycle/线程的生命周期-jdk1.5之前.png" alt="">

* jdk5.0之后：

```java
public enum Status {
    NEW,
    RUNNABLE,
    BLOCKED,
    WAITING,
    TIMED_WAITING,
    TERMINATED
}

```

<img src="./atguigu02/method_lifecycle/线程的生命周期-jdk1.5以后.png" alt="">

### 如何解决线程安全问题（重点，难点）

* 什么是线程的安全问题？多个线程操作共享数据，就有可能出现安全问题。
* 如何解决线程的安全问题？有几种方式？
    * 同步机制：①同步代码块 ②同步方法
        * 重点关注两个地方：共享数据及操作共享数据的代码；同步监视器（保证唯一性）。
    * jdk5.0新增：Lock 接口及其实现类。（保证多个线程共用同一个 Lock 的实例）。

> 在实现 Runnable 接口的方式中，同步监视器可以考虑使用：this。
>
> 在继承 Thread 类的方式中，同步监视器要慎用 this，可以考虑使用：`当前类.class`。
>
> 非静态的同步方式，默认同步监视器是this。<br>
> 静态的同步方法，默认同步监视器是当前类本身。

### 同步机制相关的问题

* 懒汉式的线程安全的写法
* 同步机制会带来的问题：死锁
    * 死锁产生的条件及规避方式

### 线程间的通信

* 在同步机制下，考虑线程间的通信
* `wait()`, `notify()`, `notifyAll()` 都需要使用在同步代码块或同步方法中。
* 高频笔试题：wait()/sleep()区别

#### 企业真题

* 什么是线程？
* 线程和进程有什么区别？
* 多线程使用场景
* 如何在java中实现多线程？
* Thread类中的 start() 和 run() 有什么区别？
* 启动一个线程是用 run() 还是 start()？
* java中 Runnable 和 Callable 有什么不同？
* 什么是线程池，为什么要使用它？
* sleep() 和 yield() 区别？
* 线程创建的方法、属性？
* 线程的生命周期？
* 线程的基本状态以及状态之间的关系？
* stop() 和 suspend() 方法为何不推荐使用？
* java 线程优先级是如何定义的？
* 如何理解线程安全？线程安全问题是如何造成的？
* 多线程共用一个数据变量需要注意什么？
* 多线程保证线程安全一般有几种方式？
* 用什么关键字修饰同步方法？
* synchronized 加在静态方法和普通方法的区别？
* java中的 synchronized 和 ReentrantLock 有什么区别？
* 当一个线程进入一个对象的一个 synchronized 方法后，其他线程是否可进入此对象的其他方法？
* 线程同步与阻塞的关系？同步一定阻塞吗？阻塞一定同步吗？
* 什么是死锁？产生死锁的原因及必要条件？
* 如何避免死锁？
* java 中 notify() 和 notifyAll() 有什么区别？
* 为什么wait() 和 notify() 方法要在同步快中调用？
* 多线程：生产者，消费者代码（同步，wait，notify编程）
* wait() 和 sleep() 有什么区别？调用这两个函数后，线程状态分别作何改变？
* 手写一个单例模式（Singleton）
* 手写一个懒汉式的单例模式，解决其线程安全问题，并且说明为什么这样子去解决？
