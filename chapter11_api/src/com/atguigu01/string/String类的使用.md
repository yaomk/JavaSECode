# String 类的理解（以 JDK 8 为例说明）

## 类的声明

```java
public final class String implements java.io.Serializable, Comparable<String>, CharSequence {
}
```

* `final:String`: 是不可被继承的
* `java.io.Serializable`: 可序列化的接口。凡是实现此接口的类的对象就可以通过网络或本地流进行数据的传输。
* `Compareable`: 凡是实现此接口的类，其对象都可以比较大小。

## 内部声明的属性

jdk8中：

`private final char value[]`: 存储字符串数据的容器

* `final`：指明此 value 数据一旦初始化，其地址就不可变。

jdk9开始：为了节省内存空间，做了优化

`private final byte value[]`: 存储字符串数据的容器

### 字符串常量的存储位置

* 字符串常量都存储在字符串常量池（StringTable）中
* 字符串常量池不允许存放两个相同的字符串常量
* 字符串常量池，在不同的jdk版本中，存放位置不同：
    * jdk7之前：字符串常量池存放在方法区
    * jdk7及之后：字符串常量池存放在堆空间

### String 的不可变性的理解

* 当对字符串变量重新赋值时，需要重新指定一个字符串常量的位置进行赋值，不能在原有的位置修改。
* 当对现有的字符串进行拼接操作时，需要重新开辟空间保存拼接以后的字符串，不能在原有的位置修改。
* 当调用字符串的 `replace()` 替换现有的某个字符串时，需要重新开辟空间保存修改以后的字符串，不能在原有的位置修改。

### String 实例化的两种方式

* `String s1 = "hello"`;
* `String s2 = new String("hello")`;

### 【面试题】

`String s1 = new String("hello");`在内存中创建了几个对象？

* 两个！
* 一个是堆空间中 new 的对象。另一个是在字符串常量池中生成的字面量。

### String的连接操作：`+`

* 情况1：`常量 + 常量`：结果仍然存储在字符串常量池中，返回此字面量的地址。注：此时的常量可能是字面量，或是 **final 修饰的常量
  **。
* 情况2：`常量 + 变量` 或 `变量 + 变量`：都会通过 new 的方式创建一个新的字符串，返回堆空间此字符串对象的地址。
* 情况3：调用字符串的 `intern()`：返回的都是字符串常量池中字面量的地址。
* 情况4：`concat()`：源码得知 concat 方法返回一个通过 new 的方式创建的新的字符串，返回堆空间中此字符串对象的地址。